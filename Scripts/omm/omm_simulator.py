"""
Generated by CHARMM-GUI (http://www.charmm-gui.org)

openmm_run.py

This program is OpenMM running scripts written in python, refactored into a
reusable Simulation class.

Original Correspondence: jul316@lehigh.edu or wonpil@lehigh.edu
Last update: February 5, 2025
"""

from __future__ import print_function
import argparse
import sys
import os
sys.path.insert(0, "/home/dibyendu/WE/New_Scripts/omm/")

# These imports are assumed to be in the same directory or in the python path
from omm_readinputs import *
from new_omm_readparams import *
from omm_vfswitch import *
from omm_barostat import *
from omm_restraints import *
from omm_rewrap import *

from openmm import *
from openmm.app import *
from openmm.unit import *

class OpenMMSimulation:
    """
    A class to set up and run an OpenMM simulation based on CHARMM-GUI inputs.
    """
    def __init__(self, inpfile, topfile, crdfile, toppar=None, sysinfo=None,
                 fftype='CHARMM', icrst=None, irst=None, ichk=None, opdb=None,
                 orst=None, ochk=None, odcd=None, rewrap=False, platform=None, device_idx = 0):
        """
        Initializes the simulation with all necessary file paths and options.

        Parameters are equivalent to the original script's command-line arguments.
        """
        # Store all input parameters
        self.inpfile = inpfile
        self.topfile = topfile
        self.crdfile = crdfile
        self.toppar = toppar
        self.sysinfo = sysinfo
        self.fftype = fftype.upper()
        self.icrst = icrst
        self.irst = irst
        self.ichk = ichk
        self.opdb = opdb
        self.orst = orst
        self.ochk = ochk
        self.odcd = odcd
        self.rewrap = rewrap
        self.platform_name = platform
        self.device_idx = device_idx
        # Initialize simulation objects to None
        self.inputs = None
        self.top = None
        self.crd = None
        self.params = None
        self.system = None
        self.integrator = None
        self.platform = None
        self.simulation = None
        ## Setting up the simulation object
        self.setup()
    def _load_parameters(self):
        """Loads parameters, topology, and coordinates from input files."""
        #print("Loading parameters")
        self.inputs = read_inputs(self.inpfile)
        self.top = read_top(self.topfile, self.fftype)
        self.crd = read_crd(self.crdfile, self.fftype)
        if self.fftype == 'CHARMM':
            self.params = read_params(self.toppar)
            self.top = read_box(self.top, self.sysinfo) if self.sysinfo else gen_box(self.top, self.crd)

    def _build_system(self):
        """Builds the OpenMM System object."""
        #print("\nBuilding system")
        inputs = self.inputs
        nboptions = dict(nonbondedMethod=inputs.coulomb,
                         nonbondedCutoff=inputs.r_off * nanometers,
                         constraints=inputs.cons,
                         ewaldErrorTolerance=inputs.ewald_Tol)
        if inputs.vdw == 'Switch': nboptions['switchDistance'] = inputs.r_on * nanometers
        if inputs.vdw == 'LJPME':  nboptions['nonbondedMethod'] = LJPME
        if inputs.implicitSolvent:
            nboptions['implicitSolvent'] = inputs.implicitSolvent
            nboptions['implicitSolventSaltConc'] = inputs.implicit_salt * (moles/liter)
            nboptions['temperature'] = inputs.temp * kelvin
            nboptions['soluteDielectric'] = inputs.solut_diele
            nboptions['solventDielectric'] = inputs.solve_diele
            nboptions['gbsaModel'] = inputs.gbsamodel

        if self.fftype == 'CHARMM':
            self.system = self.top.createSystem(self.params, **nboptions)
        elif self.fftype == 'AMBER':
            self.system = self.top.createSystem(**nboptions)

        if inputs.vdw == 'Force-switch':
            self.system = vfswitch(self.system, self.top, inputs)
        if inputs.lj_lrc == 'yes':
            for force in self.system.getForces():
                if isinstance(force, NonbondedForce): force.setUseDispersionCorrection(True)
                if isinstance(force, CustomNonbondedForce) and force.getNumTabulatedFunctions() != 1:
                    force.setUseLongRangeCorrection(True)
        if inputs.e14scale != 1.0:
            for force in self.system.getForces():
                if isinstance(force, NonbondedForce): nonbonded = force; break
            for i in range(nonbonded.getNumExceptions()):
                atom1, atom2, chg, sig, eps = nonbonded.getExceptionParameters(i)
                nonbonded.setExceptionParameters(i, atom1, atom2, chg * inputs.e14scale, sig, eps)

        if inputs.pcouple == 'yes': self.system = barostat(self.system, inputs)
        if inputs.rest == 'yes':    self.system = restraints(self.system, self.crd, inputs)

        self.integrator = LangevinIntegrator(inputs.temp*kelvin, inputs.fric_coeff/picosecond, inputs.dt*picoseconds)

    def _select_platform(self):
        """Selects the OpenMM platform for the simulation."""
        DEFAULT_PLATFORMS = 'CUDA', 'OpenCL', 'CPU'
        enabled_platforms = [Platform.getPlatform(i).getName() for i in range(Platform.getNumPlatforms())]

        if self.platform_name:
            if self.platform_name not in enabled_platforms:
                print(f"Error: Unable to find OpenMM platform '{self.platform_name}'.", file=sys.stderr)
                sys.exit(1)
            self.platform = Platform.getPlatformByName(self.platform_name)
        else:
            for p_name in DEFAULT_PLATFORMS:
                if p_name in enabled_platforms:
                    self.platform = Platform.getPlatformByName(p_name)
                    break
            if not self.platform:
                print("Error: Unable to find any of the default OpenMM platforms (CUDA, OpenCL, CPU).", file=sys.stderr)
                sys.exit(1)

        #print(f"Using platform: {self.platform.getName()}")
        self.prop = dict(CudaPrecision='single', DeviceIndex=str(self.device_idx)) if self.platform.getName() == 'CUDA' else dict()

    def _create_simulation(self):
        """Creates the main OpenMM Simulation object and sets its initial state."""
        self.simulation = Simulation(self.top.topology, self.system, self.integrator, self.platform, self.prop)
        self.simulation.context.setPositions(self.crd.positions)

        # Load state from restart/checkpoint files if provided
        if self.icrst:
            charmm_rst = read_charmm_rst(self.icrst)
            self.simulation.context.setPositions(charmm_rst.positions)
            self.simulation.context.setVelocities(charmm_rst.velocities)
            self.simulation.context.setPeriodicBoxVectors(charmm_rst.box[0], charmm_rst.box[1], charmm_rst.box[2])
        if self.irst:
            with open(self.irst, 'r') as f:
                self.simulation.context.setState(XmlSerializer.deserialize(f.read()))
        if self.ichk:
            with open(self.ichk, 'rb') as f:
                self.simulation.context.loadCheckpoint(f.read())

        # Re-wrap coordinates if requested
        if self.rewrap:
            self.simulation = rewrap(self.simulation)

        # Report initial energy
        #print("\nInitial system energy")
        #print(self.simulation.context.getState(getEnergy=True).getPotentialEnergy())

    def setup(self):
        """Runs the entire setup sequence."""
        self._load_parameters()
        self._build_system()
        self._select_platform()
        self._create_simulation()

    def minimize(self):
        """Performs energy minimization if specified in the input."""
        if self.inputs.mini_nstep > 0:
            print(f"\nEnergy minimization: {self.inputs.mini_nstep} steps")
            self.simulation.minimizeEnergy(
                tolerance=self.inputs.mini_Tol*kilojoule/mole/nanometers,
                maxIterations=self.inputs.mini_nstep
            )
            print("Minimized energy:", self.simulation.context.getState(getEnergy=True).getPotentialEnergy())

    def generate_velocities(self):
        """Generates initial velocities if specified in the input."""
        if self.inputs.gen_vel == 'yes':
            print("\nGenerating initial velocities")
            seed = self.inputs.gen_seed if self.inputs.gen_seed else None
            self.simulation.context.setVelocitiesToTemperature(self.inputs.gen_temp, seed)

    def run(self):
        """Runs the production molecular dynamics simulation."""
        if self.inputs.nstep <= 0:
            print("\nNo production steps requested.")
            return

        print(f"\nMD run: {self.inputs.nstep} steps")
        # Set up reporters
        if self.inputs.nstdcd > 0:
            if not self.odcd: self.odcd = 'output.dcd'
            self.simulation.reporters.append(DCDReporter(self.odcd, self.inputs.nstdcd))

        self.simulation.reporters.append(StateDataReporter(
            sys.stdout, self.inputs.nstout, step=True, time=True, potentialEnergy=True,
            temperature=True, progress=True, remainingTime=True, speed=True,
            totalSteps=self.inputs.nstep, separator='\t'
        ))

        # Run dynamics
        if self.inputs.annealing == 'yes':
            print("Running simulated annealing...")
            interval = self.inputs.interval
            temp = self.inputs.temp_init
            for i in range(self.inputs.nstep):
                self.integrator.setTemperature(temp * kelvin)
                self.simulation.step(1)
                temp += interval
        else:
            self.simulation.step(self.inputs.nstep)

        print("\nMD run finished.")

    def save_results(self):
        """Saves final state, checkpoint, and PDB files."""
        print("\nSaving final results...")
        if not (self.orst or self.ochk):
            self.orst = 'output.rst' # Default behavior from original script

        if self.orst:
            state = self.simulation.context.getState(getPositions=True, getVelocities=True)
            with open(self.orst, 'w') as f:
                f.write(XmlSerializer.serialize(state))
            print(f"Restart file saved to {self.orst}")

        if self.ochk:
            with open(self.ochk, 'wb') as f:
                f.write(self.simulation.context.createCheckpoint())
            print(f"Checkpoint file saved to {self.ochk}")

        if self.opdb:
            positions = self.simulation.context.getState(getPositions=True).getPositions()
            with open(self.opdb, 'w') as f:
                PDBFile.writeFile(self.top.topology, positions, f)
            print(f"Final PDB file saved to {self.opdb}")
